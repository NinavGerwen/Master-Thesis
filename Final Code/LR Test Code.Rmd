---
title: "Master Thesis Code"
author: "Nina van Gerwen (1860852)"
date: "2022-10-28"
output: html_document
---

## Functions for IRF calculations

These are necessary in data generation as we will vary the data generating model.

```{r}
source("Functions/model-calculations.R")
source("Functions/data-generation.R")
source("Functions/missingness.R")
source("Functions/data-aggregation.R")
source("Functions/lr-test-calculation.R")
source("Functions/chi-square-diff-test.R")
source("Functions/pearson-chi-sq-test.R")
source("Functions/start.values.R")
```

## Functions for model fit calculations

To fit the 1PL model, we can use the rasch() function.
To fit the 2PL model, we can use the ltm() function.
To fit the 3PL model, we can use the tpm() function.

## Empirical alpha analysis

```{r Final first run}
library(ltm)
library(dplyr)
library(mirt)
## This is for empirical alpha estimation
test_length <- as.factor(c(5, 10, 20))
sample_size <- as.factor(c(200, 300, 500, 1000, 1500))

n_sim <- 300

## We vary three factors, and for the simulation study, we 
## cross-examine them through a nested for loop

alpha_results <- data.frame(test_length = NA, sample_size = NA, LR2 = NA,
                      LR3 = NA, LR4 = NA, Chisq = NA, P_Chisq = NA,
                      Obs_PChisq = NA, Alt_Chisq = NA)

set.seed(1248)

for(a in levels(test_length)){

  for(b in levels(sample_size)){
      
      prop_1 <- rep(NA, n_sim)
      prop_2 <- rep(NA, n_sim)
      prop_3 <- rep(NA, n_sim)
      prop_4 <- rep(NA, n_sim)
      prop_5 <- rep(NA, n_sim)
      prop_6 <- rep(NA, n_sim)
      prop_7 <- rep(NA, n_sim)
      
      temp_n <- as.numeric(as.character(b))
      temp_k <- as.numeric(as.character(a))
      
      start.vals <- start.values(temp_k)
      
        for(i in 1:n_sim){
        ## Then, for every condition, generate data according to the
        ## current condition

          temp_data <- data.gen(n = temp_n, k = temp_k, 
                                model = "2PL")
          
          temp_model <- ltm(temp_data ~ z1, IRT.param = TRUE, start.val = start.vals)
          
          l_0 <- temp_model$log.Lik
        
          p_value_1 <- 1 - pchisq(q = LR.test(l_0 = l_0, data = temp_data, g = 2, start.val = start.vals), 
                              df = 2 * temp_k)
 
          p_value_2 <- 1 - pchisq(q = LR.test(l_0 = l_0, data = temp_data, g = 3, start.val = start.vals),
                              df = 2 * (2 *temp_k))
        
          p_value_3 <- 1 - pchisq(q = LR.test(l_0 = l_0, data = temp_data, g = 4, start.val = start.vals), 
                              df = 3 * (2 *temp_k))
          
          p_value_4 <- mirt.diff.test(l_0 = l_0, dataset = temp_data, k = temp_k)
          
          if(temp_k == 20){
          p_value_5 <- 1
          } else {
          p_value_5 <- pearson.test(model = temp_model, k = temp_k)
          }
          
          if(temp_k == 20){
          p_value_6 <- 1
          } else {
          p_value_6 <- obs.pearson.test(model = temp_model, k = temp_k)
          }
          
          p_value_7 <- equal.mirt.diff.test(l_0 = l_0, dataset = temp_data, k = temp_k)
          
          
          prop_1[i] <- ifelse(p_value_1 < .05, 1, 0)
          prop_2[i] <- ifelse(p_value_2 < .05, 1, 0)
          prop_3[i] <- ifelse(p_value_3 < .05, 1, 0)
          prop_4[i] <- ifelse(p_value_4 < .05, 1, 0)
          prop_5[i] <- ifelse(p_value_5 < .05, 1, 0)
          prop_6[i] <- ifelse(p_value_6 < .05, 1, 0)
          prop_7[i] <- ifelse(p_value_7 < .05, 1, 0)
        }
      
      alpha_results <- rbind(alpha_results, c(a, b, mean(prop_1), mean(prop_2), 
                                  mean(prop_3), mean(prop_4), mean(prop_5),
                                  mean(prop_6), mean(prop_7)))

  }
  
}

alpha_results <- alpha_results[-1 ,]
rownames(alpha_results) <- NULL

alpha_results
```

## Power analysis

```{r Final second run}
## This is for power estimation
set.seed(1248)

n_sim <- 300

## We vary three factors, and for the simulation study, we 
## cross-examine them through a nested for loop

## TUPLES

power_results <- data.frame(test_length = NA, sample_size = NA, LR2 = NA,
                      LR3 = NA, LR4 = NA, Chisq = NA, P_Chisq = NA,
                      Obs_PChisq = NA, Alt_Chisq = NA)

for(a in levels(test_length)){

  for(b in levels(sample_size)){
      
      prop_1 <- rep(NA, n_sim)
      prop_2 <- rep(NA, n_sim)
      prop_3 <- rep(NA, n_sim)
      prop_4 <- rep(NA, n_sim)
      prop_5 <- rep(NA, n_sim)
      prop_6 <- rep(NA, n_sim)
      prop_7 <- rep(NA, n_sim)
      
      temp_n <- as.numeric(as.character(b))
      temp_k <- as.numeric(as.character(a))
      
      start.vals <- start.values(temp_k)
      
        for(i in 1:n_sim){
        ## Then, for every condition, generate data according to the
        ## current condition

          temp_data <- data.gen(n = temp_n, 
                                k = temp_k, 
                                model = "3PL")
          
          temp_model <- ltm(temp_data ~ z1, IRT.param = TRUE, start.val = start.vals)
          
          l_0 <- temp_model$log.Lik
        
          p_value_1 <- 1 - pchisq(q = LR.test(l_0 = l_0, data = temp_data, g = 2, start.val = start.vals), 
                              df = 2 * temp_k)
 
          p_value_2 <- 1 - pchisq(q = LR.test(l_0 = l_0, data = temp_data, g = 3, start.val = start.vals),
                              df = 2 * (2 *temp_k))
        
          p_value_3 <- 1 - pchisq(q = LR.test(l_0 = l_0, data = temp_data, g = 4, start.val = start.vals), 
                              df = 3 * (2 *temp_k))
          
          p_value_4 <- mirt.diff.test(l_0 = l_0, dataset = temp_data, k = temp_k)
          
          if(temp_k == 20){
          p_value_5 <- 1
          } else {
          p_value_5 <- pearson.test(model = temp_model, k = temp_k)
          }
          
          if(temp_k == 20){
          p_value_6 <- 1
          } else {
          p_value_6 <- obs.pearson.test(model = temp_model, k = temp_k)
          }
          
          p_value_7 <- equal.mirt.diff.test(l_0 = l_0, dataset = temp_data, k = temp_k)
        
          prop_1[i] <- ifelse(p_value_1 < .05, 1, 0)
          prop_2[i] <- ifelse(p_value_2 < .05, 1, 0)
          prop_3[i] <- ifelse(p_value_3 < .05, 1, 0)
          prop_4[i] <- ifelse(p_value_4 < .05, 1, 0)
          prop_5[i] <- ifelse(p_value_5 < .05, 1, 0)
          prop_6[i] <- ifelse(p_value_6 < .05, 1, 0)
          prop_7[i] <- ifelse(p_value_7 < .05, 1, 0)
        
          }
      
      power_results <- rbind(power_results, c(a, b, mean(prop_1), mean(prop_2), 
                                  mean(prop_3), mean(prop_4), mean(prop_5),
                                  mean(prop_6), mean(prop_7)))

  }
  
}

power_results <- power_results[-1 ,]
rownames(power_results) <- NULL

power_results

power_results %>% arrange((as.numeric(test_length)))
```

## Testing

Hieronder: data generatie code voor equal gammas en -0.5 alpha
```{r}
temp.data.gen <- function(n, k, model = "1PL"){
  
  ## First, create a matrix of thetas (person parameters) by sampling
  ## from a standard normal distribution
  theta <- matrix(data = rep((rnorm(n) - .5), k), ncol = k)
  
  ## Then, create a matrix of betas (difficulty parameters) by
  ## repeating the wanted values and making a matrix out of them
  ## here, the beta values chosen are -1, -0.5, 0, etc.
  beta <- matrix(data = rep(c(-1, -0.5, 0, 0.5, 1), k), nrow = n, ncol = k, byrow = TRUE)
  
  ## If the chosen model is the 1PL: use function one.pl to
  ## properly calculate the probabilities for every person given every item
  if(model == "1PL"){
    Z <- one.pl(theta = theta, beta = beta)
    
  }
  ## If the chosen model is the 2PL: use function two.pl to
  ## properly calculate the probabilities for every person given every item
  if(model == "2PL"){
    
    ## The 2PL also has alphas in the equation (scaling parameter)
    ## Therefore, these also need to be created
    if(k == 5){
      alpha <- matrix(data = c(0.7, 0.85, 1, 1.15, 1.3), ncol = k,
                      nrow = n, byrow = TRUE)
    }
    if(k == 10){
      alpha <- matrix(data = c(0.7, 0.85, 1, 1.15, 1.3, 1.3, 1.15, 1,
                               0.85, 0.7), ncol = k, nrow = n,
                      byrow = TRUE)
    }
    if(k == 20){
      alpha <- matrix(data = c(0.7, 0.85, 1, 1.15, 1.3, 1.3, 1.15, 1,
                               0.85, 0.7, 1.15, 1.3, 0.7, 0.85, 1,
                               1, 0.7, 1.3, 0.85, 1.15), ncol = k, nrow = n,
                      byrow = TRUE)
    } else {
      alpha <- matrix(data = rep(c(0.7, 0.85, 1, 1.15, 1.3), k), ncol = k,
                      nrow = n, byrow = TRUE)
    }
    
    
    Z <- two.pl(theta = theta, alpha = alpha, beta = beta)
    
  }
  ## If the chosen model is the 3PL: use function three.pl to
  ## properly calculate the probabilities for every person given every item
  if(model == "3PL"){
    
    if(k == 5){
      alpha <- matrix(data = c(0.7, 0.85, 1, 1.15, 1.3), ncol = k,
                      nrow = n, byrow = TRUE)
    }
    if(k == 10){
      alpha <- matrix(data = c(0.7, 0.85, 1, 1.15, 1.3, 1.3, 1.15, 1,
                               0.85, 0.7), ncol = k, nrow = n,
                      byrow = TRUE)
    }
    if(k == 20){
      alpha <- matrix(data = c(0.7, 0.85, 1, 1.15, 1.3, 1.3, 1.15, 1,
                               0.85, 0.7, 1.15, 1.3, 0.7, 0.85, 1,
                               1, 0.7, 1.3, 0.85, 1.15), ncol = k, nrow = n,
                      byrow = TRUE)
    } else {
      alpha <- matrix(data = rep(c(0.7, 0.85, 1, 1.15, 1.3), k), ncol = k,
                      nrow = n, byrow = TRUE)
    }
    
    ## The 3PL has gammas in the equation (pseudo-guessing parameter),
    ## therefore we create these.
    gamma <- matrix(data = 0.15, ncol = k, 
                    nrow = n, byrow = TRUE)
    
    Z <- three.pl(theta = theta, alpha = alpha, beta = beta, gamma = gamma)
  }
  
  ## Finally, sample from a binomial distribution, given the probability
  ## matrix that we had calculated earlier
  data <- matrix(data = rbinom(n = n * k, size = 1, prob = Z), ncol = k, nrow = n)
  
  ## And return this matrix
  return(data)
  
}

```


### Testing with 3PL

```{r}
mirt.diff.test <- function(l_0, dataset, k){
  l_a <- dataset %>% 
            as.data.frame(.) %>%
            mirt(data = ., model = 1, itemtype = "3PL", optimizer = "nlminb", 
                 TOL = .0001, control = list(maxit = 1000),
                 verbose = TRUE, constrain = list(c(3, 7, 11, 15, 19))) %>% logLik(.)
  
  chisqvalue <- 2 * (l_a - l_0)
  
  p.value <- 1 - pchisq(chisqvalue, df = 1)
  
  return(p.value)
}

set.seed(1248)
p_value_4 <- rep(NA, 100)
for(i in 1:100){
          temp_data <- temp.data.gen(n = 1000, 
                                k = 5, 
                                model = "2PL")
          
          temp_model <- ltm(temp_data ~ z1, IRT.param = TRUE)
          
          l_0 <- temp_model$log.Lik
          
          p_value_4[i] <- mirt.diff.test(l_0 = l_0, dataset = temp_data, k = 5)
          
          print(p_value_4[i])
}

sum(ifelse(p_value_4 < .05, 1, 0))

set.seed(1248)
for(i in 1:100){
          temp_data <- temp.data.gen(n = 1000, 
                                k = 5, 
                                model = "3PL")
          
          temp_model <- ltm(temp_data ~ z1, IRT.param = TRUE)
          
          l_0 <- temp_model$log.Lik
          
          p_value_4[i] <- mirt.diff.test(l_0 = l_0, dataset = temp_data, k = 5)
          
          print(p_value_4[i])
}

sum(ifelse(p_value_4 < .05, 1, 0))
```
    


## Testing with looping

```{r}
test <- data.frame(TL = NA, SS = NA)
for(a in levels(test_length)){ 
  for(b in levels(sample_size)){
    
    temp_n <- as.numeric(as.character(b)) 
    temp_k <- as.numeric(as.character(a))
  for(i in 1:10){
    
    temp_data <- data.gen(n = temp_n, k = temp_k, "2PL")
    
    print(dim(temp_data))
    }
    
    test <- rbind(c(dim(temp_data)), test)

  }
  
}
test
```

        

