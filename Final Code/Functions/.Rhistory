source("Functions/model-calculations.R")
source("Functions/data-generation.R")
source("Functions/missingness.R")
source("Functions/fit-indices calculations.R")
source("Functions/data-aggregation.R")
## Data generation is based on three models, therefore we created functions for
## the calculations of every model (1PL - 2PL - 3PL)
source("Functions/model-calculations.R")
source("Functions/data-generation.R")
source("Functions/missingness.R")
source("Functions/fit-indices calculations.R")
source("Functions/data-aggregation.R")
## Data generation is based on three models, therefore we created functions for
## the calculations of every model (1PL - 2PL - 3PL)
source("Functions/model-calculations.R")
source("Functions/data-generation.R")
source("Functions/missingness.R")
source("Functions/fit-indices calculations.R")
source("Functions/data-aggregation.R")
## LTM to fit the required models
require(ltm)
## DPLYR for some tidying
require(dplyr)
## MAGRITTR for the pipe
require(magrittr)
## Here, you can define the levels of the factors you want to investigate
## for the simulation study,
test_length <- as.factor(c(5, 10, 20))
sample_size <- as.factor(c(200, 300, 500, 1000, 1500))
## And you set the number of replications you want
n_sim <- 5
## Our output will be a data frame with first the conditions, and then the
## results, and we pre-define the data frame here with some NAs
null_results <- data.frame(test_length = NA, sample_size = NA, TLI_M = NA,
TLI_SE = NA, CFI_M = NA, CFI_SE = NA, TLI_Yang = NA,
CFI_Yang = NA)
## Then set a seed for reproducibility
set.seed(1248)
## And now we start a nested for loop for the study
## With first a for loop for both factors
for(a in levels(test_length)){
for(b in levels(sample_size)){
## Then, in every condition, you create an empty vector of size
## equal to the number of replications for the fit indices
tli_values <- rep(NA, n_sim)
cfi_values <- rep(NA, n_sim)
tli_yang <- rep(NA, n_sim)
cfi_yang <- rep(NA, n_sim)
## You get the correct level of the factors as numerics
temp_n <- as.numeric(as.character(b))
temp_k <- as.numeric(as.character(a))
## And then you get results for every condition by for every
## replication, doing the following:
for(j in 1:n_sim){
## Generating data according to the factors
temp_data <- data.gen(n = temp_n, k = temp_k, model = "2PL")
## Fitting the hypothesized model
l_0 <- ltm(temp_data ~ z1, IRT.param = TRUE)$log.Lik
## Aggregrating the data
aggr_data <- score.pattern.aggr(temp_data, temp_n)
## And then calculating the TLI and CFI values through our
## specialized functions
tli_values[j] <- TLI(l_0, temp_data, aggr_data, temp_n, temp_k)
cfi_values[j] <- CFI(l_0, temp_data, aggr_data, temp_n, temp_k)
tli_yang[j] <- TLI.Yang(l_0, temp_data, aggr_data, temp_n, temp_k)
cfi_yang[j] <- CFI.Yang(l_0, temp_data, aggr_data, temp_n, temp_k)
}
## Then, after the values have been calculated n_sim times,
## we can get their mean and standard deviation and add these
## to the result dataframe through rbind()
null_results <- rbind(null_results, c(a, b, mean(tli_values), sd(tli_values),
mean(cfi_values), sd(cfi_values),
mean(tli_yang), mean(cfi_yang)))
}
}
## Now we just have to clean up the dataframe by removing the first row
null_results <- null_results[-1 ,]
## And resetting the rownames
rownames(null_results) <- NULL
## And tada! your results for the 'null-condition'
null_results
## LTM to fit the required models
require(ltm)
## DPLYR for some tidying
require(dplyr)
## MAGRITTR for the pipe
require(magrittr)
## Here, you can define the levels of the factors you want to investigate
## for the simulation study,
test_length <- as.factor(c(5, 10, 20))
sample_size <- as.factor(c(200, 300, 500, 1000, 1500))
## And you set the number of replications you want
n_sim <- 5
## Our output will be a data frame with first the conditions, and then the
## results, and we pre-define the data frame here with some NAs
miss_results <- data.frame(test_length = NA, sample_size = NA, TLI_M = NA,
TLI_SE = NA, CFI_M = NA, CFI_SE = NA, TLI_Yang = NA,
CFI_Yang = NA)
## Then set a seed for reproducibility
set.seed(1248)
## And now we start a nested for loop for the study
## With first a for loop for both factors
for(a in levels(test_length)){
for(b in levels(sample_size)){
## Then, in every condition, you create an empty vector of size
## equal to the number of replications for the fit indices
tli_values <- rep(NA, n_sim)
cfi_values <- rep(NA, n_sim)
tli_yang <- rep(NA, n_sim)
cfi_yang <- rep(NA, n_sim)
## You get the correct level of the factors as numerics
temp_n <- as.numeric(as.character(b))
temp_k <- as.numeric(as.character(a))
## And then you get results for every condition by for every
## replication, doing the following:
for(j in 1:n_sim){
## Generating data according to the factors
temp_data <- data.gen(n = temp_n, k = temp_k, model = "3PL")
## Fitting the hypothesized model
l_0 <- ltm(temp_data ~ z1, IRT.param = TRUE)$log.Lik
## Aggregrating the data
aggr_data <- score.pattern.aggr(temp_data, temp_n)
## And then calculating the TLI and CFI values through our
## specialized functions
tli_values[j] <- TLI(l_0, temp_data, aggr_data, temp_n, temp_k)
cfi_values[j] <- CFI(l_0, temp_data, aggr_data, temp_n, temp_k)
tli_yang[j] <- TLI.Yang(l_0, temp_data, aggr_data, temp_n, temp_k)
cfi_yang[j] <- CFI.Yang(l_0, temp_data, aggr_data, temp_n, temp_k)
}
## Then, after the values have been calculated n_sim times,
## we can get their mean and standard deviation and add these
## to the result dataframe through rbind()
miss_results <- rbind(miss_results, c(a, b, mean(tli_values), sd(tli_values),
mean(cfi_values), sd(cfi_values),
mean(tli_yang), mean(cfi_yang)))
}
}
## Now we just have to clean up the dataframe by removing the first row
miss_results <- null_results[-1 ,]
## And resetting the rownames
rownames(miss_results) <- NULL
## And tada! your results for the 'null-condition'
miss_results
## LTM to fit the required models
require(ltm)
## DPLYR for some tidying
require(dplyr)
## MAGRITTR for the pipe
require(magrittr)
## Here, you can define the levels of the factors you want to investigate
## for the simulation study,
test_length <- as.factor(c(5, 10, 20))
sample_size <- as.factor(c(200, 300, 500, 1000, 1500))
## And you set the number of replications you want
n_sim <- 5
## Our output will be a data frame with first the conditions, and then the
## results, and we pre-define the data frame here with some NAs
miss_results <- data.frame(test_length = NA, sample_size = NA, TLI_M = NA,
TLI_SE = NA, CFI_M = NA, CFI_SE = NA, TLI_Yang = NA,
CFI_Yang = NA)
## Then set a seed for reproducibility
set.seed(1248)
## And now we start a nested for loop for the study
## With first a for loop for both factors
for(a in levels(test_length)){
for(b in levels(sample_size)){
## Then, in every condition, you create an empty vector of size
## equal to the number of replications for the fit indices
tli_values <- rep(NA, n_sim)
cfi_values <- rep(NA, n_sim)
tli_yang <- rep(NA, n_sim)
cfi_yang <- rep(NA, n_sim)
## You get the correct level of the factors as numerics
temp_n <- as.numeric(as.character(b))
temp_k <- as.numeric(as.character(a))
## And then you get results for every condition by for every
## replication, doing the following:
for(j in 1:n_sim){
## Generating data according to the factors
temp_data <- data.gen(n = temp_n, k = temp_k, model = "3PL")
## Fitting the hypothesized model
l_0 <- ltm(temp_data ~ z1, IRT.param = TRUE)$log.Lik
## Aggregrating the data
aggr_data <- score.pattern.aggr(temp_data, temp_n)
## And then calculating the TLI and CFI values through our
## specialized functions
tli_values[j] <- TLI(l_0, temp_data, aggr_data, temp_n, temp_k)
cfi_values[j] <- CFI(l_0, temp_data, aggr_data, temp_n, temp_k)
tli_yang[j] <- TLI.Yang(l_0, temp_data, aggr_data, temp_n, temp_k)
cfi_yang[j] <- CFI.Yang(l_0, temp_data, aggr_data, temp_n, temp_k)
}
## Then, after the values have been calculated n_sim times,
## we can get their mean and standard deviation and add these
## to the result dataframe through rbind()
miss_results <- rbind(miss_results, c(a, b, mean(tli_values), sd(tli_values),
mean(cfi_values), sd(cfi_values),
mean(tli_yang), mean(cfi_yang)))
}
}
## Now we just have to clean up the dataframe by removing the first row
miss_results <- miss_results[-1 ,]
## And resetting the rownames
rownames(miss_results) <- NULL
## And tada! your results for the 'null-condition'
miss_results
library(ltm)
## This is for empirical alpha estimation
test_length <- as.factor(c(5, 10, 20))
sample_size <- as.factor(c(200, 300, 500, 1000, 1500))
n_sim <- 10
## We vary three factors, and for the simulation study, we
## cross-examine them through a nested for loop
alpha_results <- data.frame(test_length = NA, sample_size = NA, LR2 = NA,
LR3 = NA, LR4 = NA, Chisq = NA, P_Chisq = NA)
set.seed(1248)
for(a in levels(test_length)){
for(b in levels(sample_size)){
prop_1 <- rep(NA, n_sim)
prop_2 <- rep(NA, n_sim)
prop_3 <- rep(NA, n_sim)
prop_4 <- rep(NA, n_sim)
prop_5 <- rep(NA, n_sim)
temp_n <- as.numeric(as.character(b))
temp_k <- as.numeric(as.character(a))
for(i in 1:n_sim){
## Then, for every condition, generate data according to the
## current condition
temp_data <- data.gen(n = temp_n, k = temp_k,
model = "2PL")
p_value_1 <- 1 - pchisq(q = LR.test(data = temp_data,
model = "2PL", g = 2),
df = temp_k)
p_value_2 <- 1 - pchisq(q = LR.test(data = temp_data,
model = "2PL", g = 3),
df = 2 * temp_k)
p_value_3 <- 1 - pchisq(q = LR.test(data = temp_data,
model = "2PL", g = 4),
df = 3 * temp_k)
p_value_4 <- 1
p_value_5 <- 1
prop_1[i] <- ifelse(p_value_1 < .05, 1, 0)
prop_2[i] <- ifelse(p_value_2 < .05, 1, 0)
prop_3[i] <- ifelse(p_value_3 < .05, 1, 0)
prop_4[i] <- ifelse(p_value_4 < .05, 1, 0)
prop_5[i] <- ifelse(p_value_5 < .05, 1, 0)
}
alpha_results <- rbind(alpha_results, c(a, b, mean(prop_1), mean(prop_2),
mean(prop_3), mean(prop_4), mean(prop_5)))
}
}
source("Functions/model-calculations.R")
source("Functions/data-generation.R")
source("Functions/missingness.R")
source("Functions/data-aggregation.R")
source("Functions/lr-test-calculation.R")
library(ltm)
## This is for empirical alpha estimation
test_length <- as.factor(c(5, 10, 20))
sample_size <- as.factor(c(200, 300, 500, 1000, 1500))
n_sim <- 10
## We vary three factors, and for the simulation study, we
## cross-examine them through a nested for loop
alpha_results <- data.frame(test_length = NA, sample_size = NA, LR2 = NA,
LR3 = NA, LR4 = NA, Chisq = NA, P_Chisq = NA)
set.seed(1248)
for(a in levels(test_length)){
for(b in levels(sample_size)){
prop_1 <- rep(NA, n_sim)
prop_2 <- rep(NA, n_sim)
prop_3 <- rep(NA, n_sim)
prop_4 <- rep(NA, n_sim)
prop_5 <- rep(NA, n_sim)
temp_n <- as.numeric(as.character(b))
temp_k <- as.numeric(as.character(a))
for(i in 1:n_sim){
## Then, for every condition, generate data according to the
## current condition
temp_data <- data.gen(n = temp_n, k = temp_k,
model = "2PL")
p_value_1 <- 1 - pchisq(q = LR.test(data = temp_data,
model = "2PL", g = 2),
df = temp_k)
p_value_2 <- 1 - pchisq(q = LR.test(data = temp_data,
model = "2PL", g = 3),
df = 2 * temp_k)
p_value_3 <- 1 - pchisq(q = LR.test(data = temp_data,
model = "2PL", g = 4),
df = 3 * temp_k)
p_value_4 <- 1
p_value_5 <- 1
prop_1[i] <- ifelse(p_value_1 < .05, 1, 0)
prop_2[i] <- ifelse(p_value_2 < .05, 1, 0)
prop_3[i] <- ifelse(p_value_3 < .05, 1, 0)
prop_4[i] <- ifelse(p_value_4 < .05, 1, 0)
prop_5[i] <- ifelse(p_value_5 < .05, 1, 0)
}
alpha_results <- rbind(alpha_results, c(a, b, mean(prop_1), mean(prop_2),
mean(prop_3), mean(prop_4), mean(prop_5)))
}
}
alpha_results <- alpha_results[-1 ,]
rownames(alpha_results) <- NULL
View(alpha_results)
alpha <- rep(c(0.7, 0.85, 1, 1.15, 1.3), 4)
beta <- rep(c(-1, -0.5, 0, 0.5, 1), 4)
?expand.grid
expand.grid(alpha, beta)
combinations <- expand.grid(alpha, beta)
sample(combinations, 5)
combinations
?sample
sample(nrow(combinations), 5)
combinations[c(310, 323, 245, 249, 31)]
combinations[c(310, 323, 245, 249, 31) ,]
combinations
alpha
data.frame(beta = beta, alpha = alpha)
data.frame(beta = beta, alpha = sample(alpha, length(alpha)))
alpha <- rep(c(0.7, 0.85, 1, 1.15, 1.3), 4)
sample(alpha)
?tpm
tpm(temp_data)
tpm(temp_data)$Log.Lik
tpm(temp_data)$log.lik
test <- tpm(temp_data)
test$log.Lik
tpm(temp_data)$log.Lik
