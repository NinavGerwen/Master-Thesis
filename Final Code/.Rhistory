}
}
}
View(alpha_results_two)
## method options are theta or param
## n is here group size, no longer total n
multigroup.data.gen <- function(n, k, g, method = "theta", model = "2PL"){
## We want space for the final simulated matrix
data <- matrix(data = NA, nrow = n * g, ncol = k + 1)
## If method is theta, we want differences based on their latent variable
if(method == "theta"){
## Therefore, the itemparameters can be the sample for everyone, which
## we define here in matrix beta, alpha, and gamma
beta <- matrix(data = rep(c(-1, -0.5, 0, 0.5, 1), k/5), nrow = n, ncol = k, byrow = TRUE)
if(k == 5){
alpha <- matrix(data = c(0.7, 0.85, 1, 1.15, 1.3), ncol = k,
nrow = n, byrow = TRUE)
}
if(k == 10){
alpha <- matrix(data = c(0.7, 0.85, 1, 1.15, 1.3, 1.3, 1.15, 1,
0.85, 0.7), ncol = k, nrow = n,
byrow = TRUE)
}
if(k == 20){
alpha <- matrix(data = c(0.7, 0.85, 1, 1.15, 1.3, 1.3, 1.15, 1,
0.85, 0.7, 1.15, 1.3, 0.7, 0.85, 1,
1, 0.7, 1.3, 0.85, 1.15), ncol = k, nrow = n,
byrow = TRUE)
}
if(model == "3PL"){
gamma <- matrix(data = 0.25, ncol = k, nrow = n, byrow = TRUE)
}
## Now, to generate data we will work with a for loop for every group
## Therefore, we keep a counter for indexing
counter <- 1
## Then, for every group:
for(i in 1:g){
## Generate latent variables theta in a matrix with differences
## based on the group they are in (group 1 to g)
theta <- matrix(data = rep((rnorm(n) - (as.numeric(i) - 1)), k), ncol = k)
if(model == "2PL"){
Z <- two.pl(theta = theta, alpha = alpha, beta = beta)
}
if(model == "3PL"){
Z <- three.pl(theta = theta, alpha = alpha, beta = beta, gamma = gamma)
}
data[counter:(counter + n - 1) , 1:k] <- matrix(data = rbinom(n = n * k, size = 1, prob = Z),
ncol = k, nrow = n)
data[counter:(counter + n - 1), (k + 1)] <- i
counter <- counter + n
}
}
if(method == "param"){
counter <- 1
for(i in 1:g){
theta <- matrix(data = rep((rnorm(n)), k), ncol = k)
beta <- matrix(data = rep( (c(-1, -0.5, 0, 0.5, 1) - ((as.numeric(i) -  1)/ 2)) , k),
nrow = n, ncol = k, byrow = TRUE)
if(k == 5){
alpha <- matrix(data = (c(0.7, 0.85, 1, 1.15, 1.3) - ((as.numeric(i) - 1)/8)), ncol = k,
nrow = n, byrow = TRUE)
}
if(k == 10){
alpha <- matrix(data = (c(0.7, 0.85, 1, 1.15, 1.3, 1.3, 1.15, 1, 0.85, 0.7) - ((as.numeric(i) - 1)/8)), ncol = k, nrow = n,
byrow = TRUE)
}
if(k == 20){
alpha <- matrix(data = (c(0.7, 0.85, 1, 1.15, 1.3, 1.3, 1.15, 1, 0.85,
0.7, 1.15, 1.3, 0.7, 0.85, 1, 1, 0.7, 1.3, 0.85, 1.15) - ((as.numeric(i) - i)/8)), ncol = k, nrow = n,
byrow = TRUE)
}
if(model == "2PL"){
Z <- two.pl(theta = theta, alpha = alpha, beta = beta)
}
if(model == "3PL"){
gamma <- matrix(data = 0.25, ncol = k, nrow = n, byrow = TRUE)
Z <- three.pl(theta = theta, alpha = alpha, beta = beta, gamma = gamma)
}
data[counter:(counter + n - 1) , 1:k] <- matrix(data = rbinom(n = n * k, size = 1, prob = Z),
ncol = k, nrow = n)
data[counter:(counter + n - 1), (k + 1)] <- i
counter <- counter + n
}
}
return(data)
}
g <- 3
n <- 167
k <- 5
multigroup.data.gen()
multigroup.data.gen(n = n, g = g, k = k)
## For the 2PL:
two.pl <- function(theta, alpha, beta){
## Probabilities are calculated through the following formula
prob <- exp((alpha*(theta + beta))) / (1 + exp(alpha*(theta + beta)))
return(prob)
}
multigroup.data.gen(n = n, g = g, k = k)
multigroup.data.gen(n = n, g = g, k = k)
multigroup.data.gen(n = n, g = g, k = k)
multigroup.data.gen(n = n, g = g, k = k)
multigroup.data.gen(n = n, g = g, k = k)
multigroup.data.gen(n = n, g = g, k = k)
multigroup.data.gen(n = n, g = g, k = k)
multigroup.data.gen(n = n, g = g, k = k)
multigroup.data.gen(n = n, g = g, k = k)
multigroup.data.gen(n = n, g = g, k = k, method = "param")
multigroup.data.gen(n = n, g = g, k = k, method = "param")
multigroup.data.gen(n = n, g = g, k = k, method = "param")
multigroup.data.gen(n = n, g = g, k = k, method = "param")
multigroup.data.gen(n = n, g = g, k = k, method = "param")
multigroup.data.gen(n = n, g = g, k = k, method = "param")
multigroup.data.gen(n = n, g = g, k = k, method = "param")
## method options are theta or param
## n is here group size, no longer total n
multigroup.data.gen <- function(n, k, g, method = "theta", model = "2PL"){
## We want space for the final simulated matrix
data <- matrix(data = NA, nrow = n * g, ncol = k + 1)
## If method is theta, we want differences based on their latent variable
if(method == "theta"){
## Therefore, the itemparameters can be the sample for everyone, which
## we define here in matrix beta, alpha, and gamma
beta <- matrix(data = rep(c(-1, -0.5, 0, 0.5, 1), k/5), nrow = n, ncol = k, byrow = TRUE)
if(k == 5){
alpha <- matrix(data = c(0.7, 0.85, 1, 1.15, 1.3), ncol = k,
nrow = n, byrow = TRUE)
}
if(k == 10){
alpha <- matrix(data = c(0.7, 0.85, 1, 1.15, 1.3, 1.3, 1.15, 1,
0.85, 0.7), ncol = k, nrow = n,
byrow = TRUE)
}
if(k == 20){
alpha <- matrix(data = c(0.7, 0.85, 1, 1.15, 1.3, 1.3, 1.15, 1,
0.85, 0.7, 1.15, 1.3, 0.7, 0.85, 1,
1, 0.7, 1.3, 0.85, 1.15), ncol = k, nrow = n,
byrow = TRUE)
}
if(model == "3PL"){
gamma <- matrix(data = 0.25, ncol = k, nrow = n, byrow = TRUE)
}
## Now, to generate data we will work with a for loop for every group
## Therefore, we keep a counter for indexing
counter <- 1
## Then, for every group:
for(i in 1:g){
## Generate latent variables theta in a matrix with differences
## based on the group they are in (group 1 to g)
theta <- matrix(data = rep((rnorm(n) - (as.numeric(i) - 1)), k), ncol = k)
if(model == "2PL"){
Z <- two.pl(theta = theta, alpha = alpha, beta = beta)
}
if(model == "3PL"){
Z <- three.pl(theta = theta, alpha = alpha, beta = beta, gamma = gamma)
}
data[counter:(counter + n - 1) , 1:k] <- matrix(data = rbinom(n = n * k, size = 1, prob = Z),
ncol = k, nrow = n)
data[counter:(counter + n - 1), (k + 1)] <- i
counter <- counter + n
}
}
if(method == "param"){
counter <- 1
for(i in 1:g){
theta <- matrix(data = rep((rnorm(n)), k), ncol = k)
beta <- matrix(data = rep( (c(-1, -0.5, 0, 0.5, 1) - ((as.numeric(i) -  1)/2)) , k/5),
nrow = n, ncol = k, byrow = TRUE)
if(k == 5){
alpha <- matrix(data = (c(0.7, 0.85, 1, 1.15, 1.3) - ((as.numeric(i) - 1)/8)), ncol = k,
nrow = n, byrow = TRUE)
}
if(k == 10){
alpha <- matrix(data = (c(0.7, 0.85, 1, 1.15, 1.3, 1.3, 1.15, 1, 0.85, 0.7) - ((as.numeric(i) - 1)/8)), ncol = k, nrow = n,
byrow = TRUE)
}
if(k == 20){
alpha <- matrix(data = (c(0.7, 0.85, 1, 1.15, 1.3, 1.3, 1.15, 1, 0.85,
0.7, 1.15, 1.3, 0.7, 0.85, 1, 1, 0.7, 1.3, 0.85, 1.15) - ((as.numeric(i) - i)/8)), ncol = k, nrow = n,
byrow = TRUE)
}
if(model == "2PL"){
Z <- two.pl(theta = theta, alpha = alpha, beta = beta)
}
if(model == "3PL"){
gamma <- matrix(data = 0.25, ncol = k, nrow = n, byrow = TRUE)
Z <- three.pl(theta = theta, alpha = alpha, beta = beta, gamma = gamma)
}
data[counter:(counter + n - 1) , 1:k] <- matrix(data = rbinom(n = n * k, size = 1, prob = Z),
ncol = k, nrow = n)
data[counter:(counter + n - 1), (k + 1)] <- i
counter <- counter + n
}
}
return(data)
}
## method options are theta or param
## n is here group size, no longer total n
multigroup.data.gen <- function(n, k, g, method = "theta", model = "2PL"){
## We want space for the final simulated matrix
data <- matrix(data = NA, nrow = n * g, ncol = k + 1)
## If method is theta, we want differences based on their latent variable
if(method == "theta"){
## Therefore, the itemparameters can be the sample for everyone, which
## we define here in matrix beta, alpha, and gamma
beta <- matrix(data = rep(c(-1, -0.5, 0, 0.5, 1), k/5), nrow = n, ncol = k, byrow = TRUE)
if(k == 5){
alpha <- matrix(data = c(0.7, 0.85, 1, 1.15, 1.3), ncol = k,
nrow = n, byrow = TRUE)
}
if(k == 10){
alpha <- matrix(data = c(0.7, 0.85, 1, 1.15, 1.3, 1.3, 1.15, 1,
0.85, 0.7), ncol = k, nrow = n,
byrow = TRUE)
}
if(k == 20){
alpha <- matrix(data = c(0.7, 0.85, 1, 1.15, 1.3, 1.3, 1.15, 1,
0.85, 0.7, 1.15, 1.3, 0.7, 0.85, 1,
1, 0.7, 1.3, 0.85, 1.15), ncol = k, nrow = n,
byrow = TRUE)
}
if(model == "3PL"){
gamma <- matrix(data = 0.25, ncol = k, nrow = n, byrow = TRUE)
}
## Now, to generate data we will work with a for loop for every group
## Therefore, we keep a counter for indexing
counter <- 1
## Then, for every group:
for(i in 1:g){
## Generate latent variables theta in a matrix with differences
## based on the group they are in (group 1 to g)
theta <- matrix(data = rep((rnorm(n) - (as.numeric(i) - 1)), k), ncol = k)
if(model == "2PL"){
Z <- two.pl(theta = theta, alpha = alpha, beta = beta)
}
if(model == "3PL"){
Z <- three.pl(theta = theta, alpha = alpha, beta = beta, gamma = gamma)
}
data[counter:(counter + n - 1) , 1:k] <- matrix(data = rbinom(n = n * k, size = 1, prob = Z),
ncol = k, nrow = n)
data[counter:(counter + n - 1), (k + 1)] <- i
counter <- counter + n
}
}
if(method == "param"){
counter <- 1
for(i in 1:g){
theta <- matrix(data = rep((rnorm(n)), k), ncol = k)
beta <- matrix(data = rep( (c(-1, -0.5, 0, 0.5, 1) - ((as.numeric(i) -  1)/2)) , k/5),
nrow = n, ncol = k, byrow = TRUE)
if(k == 5){
alpha <- matrix(data = (c(0.7, 0.85, 1, 1.15, 1.3) - ((as.numeric(i) - 1)/8)), ncol = k,
nrow = n, byrow = TRUE)
}
if(k == 10){
alpha <- matrix(data = (c(0.7, 0.85, 1, 1.15, 1.3, 1.3, 1.15, 1, 0.85, 0.7) - ((as.numeric(i) - 1)/8)), ncol = k, nrow = n,
byrow = TRUE)
}
if(k == 20){
alpha <- matrix(data = (c(0.7, 0.85, 1, 1.15, 1.3, 1.3, 1.15, 1, 0.85,
0.7, 1.15, 1.3, 0.7, 0.85, 1, 1, 0.7, 1.3, 0.85, 1.15) - ((as.numeric(i) - i)/8)), ncol = k, nrow = n,
byrow = TRUE)
}
if(model == "2PL"){
Z <- two.pl(theta = theta, alpha = alpha, beta = beta)
}
if(model == "3PL"){
gamma <- matrix(data = 0.25, ncol = k, nrow = n, byrow = TRUE)
Z <- three.pl(theta = theta, alpha = alpha, beta = beta, gamma = gamma)
}
data[counter:(counter + n - 1) , 1:k] <- matrix(data = rbinom(n = n * k, size = 1, prob = Z),
ncol = k, nrow = n)
data[counter:(counter + n - 1), (k + 1)] <- i
counter <- counter + n
}
}
return(data)
}
multigroup.data.gen(n = n, g = g, k = k, method = "param")
multigroup.data.gen(n = n, g = g, k = k, method = "param")
multigroup.data.gen(n = n, g = g, k = k, method = "param")
multigroup.data.gen(n = n, g = g, k = k, method = "param")
multigroup.data.gen(n = n, g = g, k = k, method = "param")
source("Functions/model-calculations.R")
##source("Functions/data-aggregation.R")
##source("Functions/chi-square-diff-test.R")
##source("Functions/pearson-chi-sq-test.R")
source("Functions/start.values.R")
source("Functions/multigroup-data-gen.R")
source("Functions/multigroup-lr-test-calculation.R")
source("Functions/model-calculations.R")
##source("Functions/data-aggregation.R")
##source("Functions/chi-square-diff-test.R")
##source("Functions/pearson-chi-sq-test.R")
source("Functions/start.values.R")
source("Functions/multigroup-data-gen.R")
source("Functions/multigroup-lr-test-calculation.R")
library(ltm)
library(dplyr)
library(mirt)
## This is for empirical alpha estimation
test_length <- as.factor(c(5, 10, 20))
sample_size <- as.factor(c(200, 300, 500, 1000, 1500))
n_groups <- as.factor(c(2, 3, 4))
n_sim <- 30
alpha_results_two <- data.frame(test_length = NA, sample_size = NA, G = NA, MG.LR = NA)
set.seed(1248)
for(a in levels(test_length)){
for(b in levels(sample_size)){
for(d in levels(n_groups)){
prop_1 <- rep(NA, n_sim)
temp_k <- as.numeric(as.character(a))
temp_g <- as.numeric(as.character(d))
temp_n <- round(as.numeric(as.character(b))/temp_g)
start.vals <- start.values(temp_k)
for(i in 1:n_sim){
## Then, for every condition, generate data according to the
## current condition
temp_data <- multigroup.data.gen(n = temp_n, k = temp_k, g = temp_g,
method = "param", model = "2PL")
temp_model <- ltm(temp_data[ , 1:temp_k] ~ z1, IRT.param = TRUE)
l_0 <- temp_model$log.Lik
p_value_1 <- 1 - pchisq(q = MG.LR.test(l_0 = l_0, data = temp_data, g = temp_g,
k = temp_k, start.val = start.vals),
df = (temp_g - 1) * 2 * temp_k)
prop_1[i] <- ifelse(p_value_1 < .05, 1, 0)
print(prop_1[i])
print(temp_n)
}
alpha_results_two <- rbind(alpha_results_two, c(a, b, d, mean(prop_1)))
}
}
}
View(alpha_results_two)
library(tidyverse)
alpha_results_two %>% pivot_wider()
?pivot_wider
alpha_results_two %>% pivot_wider(., names_from = G)
alpha_results_two %>% pivot_wider(., values_from = G)
alpha_results_two %>% pivot_wider(., names_from = MG.LR, values_from = G)
alpha_results_two %>% pivot_wider(., names_from = G, values_from = G)
alpha_results_two %>% pivot_wider(., names_from = sample_size, values_from = G)
alpha_results_two %>% pivot_wider(., names_from = G, values_from = c(sample_size, G))
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR)
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR,
names_prefix = LR)
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR,
names_prefix = MG.LR)
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR)
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR, names_glue = "{variable}_{.value}")
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR, names_glue = "MG.LR")
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR, names_glue = "LR")
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR, names_glue = what)
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR, names_sep = ".")
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR, names_sep = "LR")
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR, names_sep = "LR")
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR) %>%
filter(!"NA")
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR) %>%
filter(-"NA")
?tidyverse
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR)
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR)
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR) %>% subset(-'NA')
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR) %>% summary(.)
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR) %>% filter(., -NA)
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR) %>% .[, -3]
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR) %>% .[, -3] %>% transform(., LR2 = '2')
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR) %>% .[, -3] %>% transform(.)
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR) %>% .[, -3] %>% colnames(.)
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR) %>% .[, -3] %>% transform(., LR2 = "2")
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR) %>% .[, -3] %>% transform(., LR2 = X2)
?pivot_wider
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR) %>%
.[, -3]
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR) %>%
.[, -3] %>% transmute(LR2 = 2)
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR) %>%
.[, -3]
alpha_results_two %>% pivot_wider(., names_from = G, values_from = MG.LR) %>%
.[-1, -3]
alpha_results_two <- alpha_results_two %>%
pivot_wider(., names_from = G, values_from = MG.LR) %>%
.[-1, -3]
rownames(alpha_results_two) <- NULL
colnamse(alpha_results_two) <- c("test_length", "sample_size", "LR2", "LR3", "LR4")
alpha_results_two
colnames(alpha_results_two) <- c("test_length", "sample_size", "LR2", "LR3", "LR4")
alpha_results_two
library(ltm)
library(dplyr)
library(mirt)
library(tidyr)
## This is for empirical alpha estimation
test_length <- as.factor(c(5, 10, 20))
sample_size <- as.factor(c(200, 300, 500, 1000, 1500))
n_groups <- as.factor(c(2, 3, 4))
n_sim <- 300
## We vary three factors, and for the simulation study, we
## cross-examine them through a nested for loop
alpha_results_two <- data.frame(test_length = NA, sample_size = NA, G = NA, MG.LR = NA)
set.seed(1248)
for(a in levels(test_length)){
for(b in levels(sample_size)){
for(d in levels(n_groups)){
prop_1 <- rep(NA, n_sim)
temp_k <- as.numeric(as.character(a))
temp_g <- as.numeric(as.character(d))
temp_n <- round(as.numeric(as.character(b))/temp_g)
start.vals <- start.values(temp_k)
for(i in 1:n_sim){
## Then, for every condition, generate data according to the
## current condition
temp_data <- multigroup.data.gen(n = temp_n, k = temp_k, g = temp_g,
method = "param", model = "2PL")
temp_model <- ltm(temp_data[ , 1:temp_k] ~ z1, IRT.param = TRUE)
l_0 <- temp_model$log.Lik
p_value_1 <- 1 - pchisq(q = MG.LR.test(l_0 = l_0, data = temp_data, g = temp_g,
k = temp_k, start.val = start.vals),
df = (temp_g - 1) * 2 * temp_k)
prop_1[i] <- ifelse(p_value_1 < .05, 1, 0)
print(prop_1[i])
print(temp_n)
}
alpha_results_two <- rbind(alpha_results_two, c(a, b, d, mean(prop_1)))
}
}
}
alpha_results_two <- alpha_results_two %>%
pivot_wider(., names_from = G, values_from = MG.LR) %>%
.[-1, -3]
rownames(alpha_results_two) <- NULL
colnames(alpha_results_two) <- c("test_length", "sample_size", "LR2", "LR3", "LR4")
alpha_results_two
##round(alpha_results_two, digits = 3)
theta_alpha <- data.frame(test_length = NA, sample_size = NA, G = NA, MG.LR = NA)
set.seed(1248)
for(a in levels(test_length)){
for(b in levels(sample_size)){
for(d in levels(n_groups)){
prop_1 <- rep(NA, n_sim)
temp_n <- as.numeric(as.character(b))
temp_k <- as.numeric(as.character(a))
temp_g <- as.numeric(as.character(d))
start.vals <- start.values(temp_k)
for(i in 1:n_sim){
## Then, for every condition, generate data according to the
## current condition
temp_data <- multigroup.data.gen(n = temp_n, k = temp_k, g = temp_g,
method = "theta", model = "2PL")
temp_model <- ltm(temp_data[ , 1:temp_k] ~ z1, IRT.param = TRUE)
l_0 <- temp_model$log.Lik
p_value_1 <- 1 - pchisq(q = MG.LR.test(l_0 = l_0, data = temp_data, g = temp_g,
k = temp_k, start.val = start.vals),
df = (temp_g - 1) * 2 * temp_k)
prop_1[i] <- ifelse(p_value_1 < .05, 1, 0)
}
theta_alpha <- rbind(theta_alpha, c(a, as.numeric(as.character(b)) * 4, d, mean(prop_1)))
}
}
}
source("Functions/model-calculations.R")
##source("Functions/data-aggregation.R")
##source("Functions/chi-square-diff-test.R")
##source("Functions/pearson-chi-sq-test.R")
source("Functions/start.values.R")
source("Functions/multigroup-data-gen.R")
source("Functions/multigroup-lr-test-calculation.R")
source("Functions/model-calculations.R")
##source("Functions/data-aggregation.R")
##source("Functions/chi-square-diff-test.R")
##source("Functions/pearson-chi-sq-test.R")
source("Functions/start.values.R")
source("Functions/multigroup-data-gen.R")
source("Functions/multigroup-lr-test-calculation.R")
library(ltm)
library(dplyr)
library(mirt)
library(tidyr)
## This is for empirical alpha estimation
test_length <- as.factor(c(5, 10, 20))
sample_size <- as.factor(c(200, 300, 500, 1000, 1500))
n_groups <- as.factor(c(2, 3, 4))
n_sim <- 300
## We vary three factors, and for the simulation study, we
## cross-examine them through a nested for loop
alpha_results_two <- data.frame(test_length = NA, sample_size = NA, G = NA, MG.LR = NA)
set.seed(1248)
for(a in levels(test_length)){
for(b in levels(sample_size)){
for(d in levels(n_groups)){
prop_1 <- rep(NA, n_sim)
temp_k <- as.numeric(as.character(a))
temp_g <- as.numeric(as.character(d))
temp_n <- round(as.numeric(as.character(b))/temp_g)
start.vals <- start.values(temp_k)
for(i in 1:n_sim){
## Then, for every condition, generate data according to the
## current condition
temp_data <- multigroup.data.gen(n = temp_n, k = temp_k, g = temp_g,
method = "param", model = "2PL")
temp_model <- ltm(temp_data[ , 1:temp_k] ~ z1, IRT.param = TRUE)
l_0 <- temp_model$log.Lik
p_value_1 <- 1 - pchisq(q = MG.LR.test(l_0 = l_0, data = temp_data, g = temp_g,
k = temp_k, start.val = start.vals),
df = (temp_g - 1) * 2 * temp_k)
prop_1[i] <- ifelse(p_value_1 < .05, 1, 0)
}
alpha_results_two <- rbind(alpha_results_two, c(a, b, d, mean(prop_1)))
}
}
}
View(alpha_results_two)
