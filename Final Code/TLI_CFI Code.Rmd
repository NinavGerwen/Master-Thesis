---
title: "Example of a Simulation Study using Randomly Generated IRT Data"
author: "Nina van Gerwen (1860852)"
date: "21-01-2023"
output: html_document
---

## Loading the functions

To load the functions, we use source() and choose the appropriate files. To 
find out how the functions work exactly, please look at the function files directly.

```{r IRF calculation functions}
## Data generation is based on three models, therefore we created functions for
## the calculations of every model (1PL - 2PL - 3PL)

source("Functions/model-calculations.R")
source("Functions/data-generation.R")
source("Functions/missingness.R")
source("Functions/fit-indices calculations.R")
source("Functions/data-aggregation.R")

```

## Null condition

```{r}
## LTM to fit the required models
require(ltm)
## DPLYR for some tidying
require(dplyr)
## MAGRITTR for the pipe
require(magrittr)

## Here, we define the levels of the factors we want to investigate
## for the simulation study,
test_length <- as.factor(c(5, 10, 20))
sample_size <- as.factor(c(200, 300, 500, 1000, 1500))

## And we set the number of replications you want
n_sim <- 300

## Our output will be a data frame with first the conditions, and then the
## results, and we pre-define the data frame here with some NAs
## so that later we can put the results in here
null_results <- data.frame(test_length = NA, sample_size = NA, TLI_M = NA,
                          TLI_SE = NA, CFI_M = NA, CFI_SE = NA, New_FI_M = NA,
                          New_FI_SE = NA)

## Set a seed for reproducibility
set.seed(1248)

## And to run the study, we start a nested for loop

## With first a for loop for both factors
for(a in levels(test_length)){

  for(b in levels(sample_size)){
      
      ## Then, in every condition, we want to get a vector that can 
      ## contain the fit index values for every replication, so we 
      ## create an empty vector of size
      ## equal to the number of replications for the fit indices
      tli_values <- rep(NA, n_sim)
      cfi_values <- rep(NA, n_sim)
      new_fi <- rep(NA, n_sim)
      
      ## To improve efficiency, we note the current levels of factors
      ## so that we can refer to this in future function arguments
      temp_n <- as.numeric(as.character(b))
      temp_k <- as.numeric(as.character(a))
      
        ## And now we can start the for loop by which we will get the
        ## fit index value results
        for(j in 1:n_sim){
          
          ## Getting results is done in the following way:
    
          ## First, generating data according to the factors
          temp_data <- data.gen(n = temp_n, k = temp_k, model = "2PL")
                        
          ## Then fitting the hypothesized model
          temp_model <- ltm(temp_data ~ z1, IRT.param = TRUE)
          
    ## For efficiency purposes, we note all these values once instead
    ## of for every single fit index 
          
          ## And obtaining the log likelihood
          l_0 <- temp_model$log.Lik
          
          ## For the saturated model, we require an aggregrated version 
          ## of the data, therefore we note this 
          aggr_data <- score.pattern.aggr(temp_data, temp_n)
          
          ## We note the degrees of freedom for the different tested models
          ## through pre-defined functions
          df_base <- df.base(k = temp_k)
          
          df_tested <- df.tested(k = temp_k)
          
          ## And also note  the chi-square values
          chi_base <- chi.base(agg_data = aggr_data, data = temp_data,
                               n = temp_n, k = temp_k)
          
          chi_tested <- chi.tested(l_0 = l_0, agg_data = aggr_data, n = temp_n)
          
          ## And then calculating the TLI and CFI values through our
          ## specialized functions using the earlier determined df and 
          ## chi-square values
          tli_values[j] <- TLI.Yang(chi_base = chi_base, df_base = df_base, 
                               chi_tested = chi_tested, df_tested = df_tested)
          
          cfi_values[j] <- CFI.Yang(chi_base = chi_base, df_base = df_base, 
                               chi_tested = chi_tested, df_tested = df_tested)
          
          ## And for the new fit index, we work 
          new_fi[j] <- exp.obs.FI(temp_model, temp_k)
          
        }
      
      ## Then, after the values have been calculated n_sim times, 
      ## we can get their mean and standard deviation and add these
      ## to the result dataframe through rbind()
      null_results <- rbind(null_results, c(a, b, mean(tli_values), sd(tli_values),
                                          mean(cfi_values), sd(cfi_values),
                                          mean(new_fi), sd(new_fi)))

  }
  
}

## Now we just have to clean up the dataframe by removing the first row of NAs
null_results <- null_results[-1 ,]
## And resetting the rownames
rownames(null_results) <- NULL

## And tada! your results for the 'null-condition'
null_results
```

TLI en CFI values lijken op beide calculatie methodes erg naar beneden
te gaan met aantal items. Dit betekent dat relatief aan het aantal items, 
het base model het stukken beter doet ten opzichte van het hypothesized 
model? Komt dit omdat ons base model gewoon een erg goed/efficient model is?

## Miss-specification condition

```{r}
## LTM to fit the required models
require(ltm)
## DPLYR for some tidying
require(dplyr)
## MAGRITTR for the pipe
require(magrittr)

## Here, you can define the levels of the factors you want to investigate
## for the simulation study,
test_length <- as.factor(c(5, 10, 20))
sample_size <- as.factor(c(200, 300, 500, 1000, 1500))

## And you set the number of replications you want
n_sim <- 300

## Our output will be a data frame with first the conditions, and then the
## results, and we pre-define the data frame here with some NAs
miss_results <- data.frame(test_length = NA, sample_size = NA, TLI_M = NA,
                          TLI_SE = NA, CFI_M = NA, CFI_SE = NA, New_FI_M = NA,
                          New_FI_SE = NA8)

## Then set a seed for reproducibility
set.seed(1248)

## And now we start a nested for loop for the study

## With first a for loop for both factors
for(a in levels(test_length)){

  for(b in levels(sample_size)){
      
      ## Then, in every condition, you create an empty vector of size
      ## equal to the number of replications for the fit indices
      tli_values <- rep(NA, n_sim)
      cfi_values <- rep(NA, n_sim)
      new_fi <- rep(NA, n_sim)
      
      ## You get the correct level of the factors as numerics
      temp_n <- as.numeric(as.character(b))
      temp_k <- as.numeric(as.character(a))
      
        ## And then you get results for every condition by for every
        ## replication, doing the following:
        for(j in 1:n_sim){
    
          ## Generating data according to the factors
          temp_data <- data.gen(n = temp_n, k = temp_k, model = "3PL")
                        
          ## Fitting the hypothesized model
          temp_model <- ltm(temp_data ~ z1, IRT.param = TRUE)
          
          l_0 <- temp_model$log.Lik
          
          ## Aggregrating the data
          aggr_data <- score.pattern.aggr(temp_data, temp_n)
          
          df_base <- df.base(k = temp_k)
          
          df_tested <- df.tested(k = temp_k)
          
          chi_base <- chi.base(agg_data = aggr_data, data = temp_data,
                               n = temp_n, k = temp_k)
          
          chi_tested <- chi.tested(l_0 = l_0, agg_data = aggr_data, n = temp_n)
          
          ## And then calculating the TLI and CFI values through our
          ## specialized functions
          tli_values[j] <- TLI.Yang(chi_base = chi_base, df_base = df_base, 
                               chi_tested = chi_tested, df_tested = df_tested)
          
          cfi_values[j] <- CFI.Yang(chi_base = chi_base, df_base = df_base, 
                               chi_tested = chi_tested, df_tested = df_tested)
          
          new_fi[j] <- exp.obs.FI(model = temp_model, k = temp_k)
        
        }
      
      ## Then, after the values have been calculated n_sim times, 
      ## we can get their mean and standard deviation and add these
      ## to the result dataframe through rbind()
      miss_results <- rbind(miss_results, c(a, b, mean(tli_values, na.rm = TRUE), sd(tli_values, na.rm = TRUE),
                                          mean(cfi_values, na.rm = TRUE), sd(cfi_values, na.rm = TRUE),
                                          mean(new_fi, na.rm = TRUE), sd(new_fi, na.rm = TRUE)))

  }
  
}

## Now we just have to clean up the dataframe by removing the first row
miss_results <- miss_results[-1 ,]
## And resetting the rownames
rownames(miss_results) <- NULL

## And tada! your results for the 'miss-condition'
miss_results
```

Miss results zijn iig stukken lager nog!