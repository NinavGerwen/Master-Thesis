## Data generation is based on three models, therefore we created functions for
## the calculations of every model (1PL - 2PL - 3PL)
one.pl <- function(theta, beta){
prob <- exp(theta - beta) / (1 + exp(theta - beta))
return(prob)
}
two.pl <- function(theta, alpha, beta){
prob <- exp((alpha * theta) + beta) / (1 + exp((alpha * theta) + beta))
return(prob)
}
three.pl <- function(theta, alpha, beta, gamma){
prob <- gamma + (1 - gamma) * (exp((alpha * theta) + beta) / (1 + exp((alpha + theta) + beta)))
return(prob)
}
data.gen <- function(n, k, model = "1PL"){
theta <- matrix(data = rep(rnorm(n), k), ncol = k)
beta <- matrix(data = rep(c(-2, -1, 0, 1, 2), k), nrow = n, ncol = k, byrow = TRUE)
if(model == "1PL"){
Z <- one.pl(theta = theta, beta = beta)
}
if(model == "2PL"){
alpha <- matrix(data = rep(c(0.7, 0.85, 1, 1.15, 1.3), k), ncol = k,
nrow = n, byrow = TRUE)
Z <- two.pl(theta = theta, alpha = alpha, beta = beta)
}
if(model == "3PL"){
alpha <- matrix(data = rep(c(0.7, 0.85, 1, 1.15, 1.3), k), ncol = k,
nrow = n, byrow = TRUE)
gamma <- matrix(data = rep(c(0.05, 0.08, 0.11, 0.14, 0.17), k), ncol = k,
nrow = n, byrow = TRUE)
Z <- three.pl(theta = theta, alpha = alpha, beta = beta, gamma = gamma)
}
data <- matrix(data = rbinom(n = n * k, size = 1, prob = Z), ncol = k, nrow = n)
return(data)
}
LR.test <- function(data, model = "1PL", g = 2){
temp_data <- as.data.frame(data)
temp_data$split <- sample(1:g, nrow(data), replace = TRUE)
if(model == "1PL"){
whole_log <- rasch(data = data)$log.Lik
}
if(model == "2PL"){
whole_log <- ltm(data ~ z1, IRT.param = TRUE)$log.Lik
}
if(model == "3PL"){
## safeguard voor convergeren
whole_log <- tpm(data, start.val = "random")$log.Lik
}
split_LR_values <- rep(NA, g)
for(j in 1:g) {
if(model == "1PL"){
split_LR_values[j] <- rasch(subset(temp_data, split == j, select = -split))$log.Lik
}
if(model == "2PL"){
split_LR_values[j] <- ltm(subset(temp_data, split == j, select = -split) ~ z1, IRT.param = TRUE)$log.Lik
}
if(model == "3PL"){
split_LR_values[j] <- tpm(subset(temp_data, split == j, select = -split),
start.val = "random")$log.Lik
}
}
LR_value <- whole_log / prod(split_LR_values, na.rm = TRUE)
return(LR_value)
}
degree.function <- function(model = "1PL", k, g = NULL){
if(is.null(g)){
if(model == "1PL"){
df <- k
}
if(model == "2PL"){
df <- 2 * k
}
if(model == "3PL"){
df <- 3 * k
}
} else {
if(model == "1PL"){
df <- g * k
}
if(model == "2PL"){
df <- 2 * g * k
}
if(model == "3PL"){
df <- 3 * g * k
}
}
return(df)
}
deltadf <- function(model.1, model.2) {
d_df <- degree.function(model.1) - degree.function(model.2)
return(d_df)
}
base.model <- function(data) {
k <- ncol(data)
n <- nrow(data)
pi <- rep(NA, k)
for(i in 1:k) {
n_i <- sum(data[, i] == 1)
pi_i <- mean(data[, i])
pi[i] <- (pi_i)^n_i * (1 - (pi_i))^(n - n_i)
}
loglik <- log(prod(pi))
return(loglik)
}
sat.model <- function(agg_data) {
n <- nrow(agg_data)
pi <- rep(NA, n)
for(i in 1:n) {
n_x <- agg_data$frequency[i]
pi[i] <- n_x / n
}
loglik <- log(prod(pi))
return(loglik)
}
library(ltm)
test_dat <- data.gen(50, 15, "2PL")
mml2 <- ltm(test_dat ~ z1, IRT.param = TRUE)
control <- list(iter.qN = 5000, GHk = 50)
mml3 <- tpm(test_dat, start.val = "random", max.guessing = .3,
control = control)
## Setting constraings: how to make gamma all equal, but not to
## a certain value??
r <- cbind(1:15, rep(1, 15), rep(.25, 15))
mml4 <- tpm(test_dat, start.val = "random",
constraint = r, control = control)
mml4
anova(mml1, mml2)
library(ltm)
## This is for empirical alpha estimation
test_length <- as.factor(c(5, 10, 20))
sample_size <- as.factor(c(200, 300, 500, 1000, 1500))
n_sim <- 10
## We vary three factors, and for the simulation study, we
## cross-examine them through a nested for loop
alpha_results <- data.frame(test_length = NA, sample_size = NA, LR2 = NA,
LR3 = NA, LR4 = NA, Chisq = NA, P_Chisq = NA)
for(a in levels(test_length)){
for(b in levels(sample_size)){
prop_1 <- rep(NA, n_sim)
prop_2 <- rep(NA, n_sim)
prop_3 <- rep(NA, n_sim)
prop_4 <- rep(NA, n_sim)
prop_5 <- rep(NA, n_sim)
for(i in 1:n_sim){
## Then, for every condition, generate data according to the
## current condition
n <- as.numeric(as.character(b))
k <- as.numeric(as.character(a))
temp_data <- data.gen(n = n, k = k,
model = "2PL")
p_value_1 <- 1 - pchisq(q = -2 * LR.test(data = temp_data,
model = "2PL", g = 2),
df = k)
p_value_2 <- 1 - pchisq(q = -2 * LR.test(data = temp_data,
model = "2PL", g = 3),
df = 2 * k)
p_value_3 <- 1 - pchisq(q = -2 * LR.test(data = temp_data,
model = "2PL", g = 4),
df = 3 * k)
p_value_4 <- 1
p_value_5 <- 1
prop_1[i] <- ifelse(p_value_1 < .05, 1, 0)
prop_2[i] <- ifelse(p_value_2 < .05, 1, 0)
prop_3[i] <- ifelse(p_value_3 < .05, 1, 0)
prop_4[i] <- ifelse(p_value_4 < .05, 1, 0)
prop_5[i] <- ifelse(p_value_5 < .05, 1, 0)
}
alpha_results <- rbind(alpha_results, c(a, b, mean(prop_1), mean(prop_2),
mean(prop_3), mean(prop_4), mean(prop_5)))
}
}
View(alpha_results)
library(ltm)
## This is for empirical alpha estimation
test_length <- as.factor(c(5, 10, 20))
sample_size <- as.factor(c(200, 300, 500, 1000, 1500))
n_sim <- 10
## We vary three factors, and for the simulation study, we
## cross-examine them through a nested for loop
alpha_results <- data.frame(test_length = NA, sample_size = NA, LR2 = NA,
LR3 = NA, LR4 = NA, Chisq = NA, P_Chisq = NA)
for(a in levels(test_length)){
for(b in levels(sample_size)){
prop_1 <- rep(NA, n_sim)
prop_2 <- rep(NA, n_sim)
prop_3 <- rep(NA, n_sim)
prop_4 <- rep(NA, n_sim)
prop_5 <- rep(NA, n_sim)
temp_n <- as.numeric(as.character(b))
temp_k <- as.numeric(as.character(a))
for(i in 1:n_sim){
## Then, for every condition, generate data according to the
## current condition
temp_data <- data.gen(n = temp_n, k = temp_k,
model = "2PL")
p_value_1 <- 1 - pchisq(q = -2 * LR.test(data = temp_data,
model = "2PL", g = 2),
df = k)
p_value_2 <- 1 - pchisq(q = -2 * LR.test(data = temp_data,
model = "2PL", g = 3),
df = 2 * k)
p_value_3 <- 1 - pchisq(q = -2 * LR.test(data = temp_data,
model = "2PL", g = 4),
df = 3 * k)
p_value_4 <- 1
p_value_5 <- 1
prop_1[i] <- ifelse(p_value_1 < .05, 1, 0)
prop_2[i] <- ifelse(p_value_2 < .05, 1, 0)
prop_3[i] <- ifelse(p_value_3 < .05, 1, 0)
prop_4[i] <- ifelse(p_value_4 < .05, 1, 0)
prop_5[i] <- ifelse(p_value_5 < .05, 1, 0)
}
alpha_results <- rbind(alpha_results, c(a, b, mean(prop_1), mean(prop_2),
mean(prop_3), mean(prop_4), mean(prop_5)))
}
}
alpha_results <- alpha_results[-1 ,]
rownames(alpha_results) <- NULL
View(alpha_results)
View(alpha_results)
library(ltm)
## This is for empirical alpha estimation
test_length <- as.factor(c(5, 10, 20))
sample_size <- as.factor(c(200, 300, 500, 1000, 1500))
n_sim <- 50
## We vary three factors, and for the simulation study, we
## cross-examine them through a nested for loop
alpha_results <- data.frame(test_length = NA, sample_size = NA, LR2 = NA,
LR3 = NA, LR4 = NA, Chisq = NA, P_Chisq = NA)
set.seed(1248)
for(a in levels(test_length)){
for(b in levels(sample_size)){
prop_1 <- rep(NA, n_sim)
prop_2 <- rep(NA, n_sim)
prop_3 <- rep(NA, n_sim)
prop_4 <- rep(NA, n_sim)
prop_5 <- rep(NA, n_sim)
temp_n <- as.numeric(as.character(b))
temp_k <- as.numeric(as.character(a))
for(i in 1:n_sim){
## Then, for every condition, generate data according to the
## current condition
temp_data <- data.gen(n = temp_n, k = temp_k,
model = "2PL")
p_value_1 <- 1 - pchisq(q = -2 * LR.test(data = temp_data,
model = "2PL", g = 2),
df = k)
p_value_2 <- 1 - pchisq(q = -2 * LR.test(data = temp_data,
model = "2PL", g = 3),
df = 2 * k)
p_value_3 <- 1 - pchisq(q = -2 * LR.test(data = temp_data,
model = "2PL", g = 4),
df = 3 * k)
p_value_4 <- 1
p_value_5 <- 1
prop_1[i] <- ifelse(p_value_1 < .05, 1, 0)
prop_2[i] <- ifelse(p_value_2 < .05, 1, 0)
prop_3[i] <- ifelse(p_value_3 < .05, 1, 0)
prop_4[i] <- ifelse(p_value_4 < .05, 1, 0)
prop_5[i] <- ifelse(p_value_5 < .05, 1, 0)
}
alpha_results <- rbind(alpha_results, c(a, b, mean(prop_1), mean(prop_2),
mean(prop_3), mean(prop_4), mean(prop_5)))
}
}
alpha_results <- alpha_results[-1 ,]
rownames(alpha_results) <- NULL
View(alpha_results)
View(alpha_results)
## This is for power estimation
n_sim <- 50
## We vary three factors, and for the simulation study, we
## cross-examine them through a nested for loop
## TUPLES
power_results <- data.frame(test_length = NA, sample_size = NA, LR2 = NA,
LR3 = NA, LR4 = NA, Chisq = NA, P_Chisq = NA)
for(a in levels(test_length)){
for(b in levels(sample_size)){
prop_1 <- rep(NA, n_sim)
prop_2 <- rep(NA, n_sim)
prop_3 <- rep(NA, n_sim)
prop_4 <- rep(NA, n_sim)
prop_5 <- rep(NA, n_sim)
n <- as.numeric(as.character(b))
k <- as.numeric(as.character(a))
for(i in 1:n_sim){
## Then, for every condition, generate data according to the
## current condition
temp_data <- data.gen(n = n,
k = k,
model = "3PL")
p_value_1 <- 1 - pchisq(q = -2 * LR.test(data = temp_data,
model = "2PL", g = 2),
df = k)
p_value_2 <- 1 - pchisq(q = -2 * LR.test(data = temp_data,
model = "2PL", g = 3),
df = 2 * k)
p_value_3 <- 1 - pchisq(q = -2 * LR.test(data = temp_data,
model = "2PL", g = 4),
df = 3 * k)
p_value_4 <- 1
p_value_5 <- 1
prop_1[i] <- ifelse(p_value_1 < .05, 1, 0)
prop_2[i] <- ifelse(p_value_2 < .05, 1, 0)
prop_3[i] <- ifelse(p_value_3 < .05, 1, 0)
prop_4[i] <- ifelse(p_value_4 < .05, 1, 0)
prop_5[i] <- ifelse(p_value_5 < .05, 1, 0)
}
power_results <- rbind(results, c(a, b, mean(prop_1), mean(prop_2),
mean(prop_3), mean(prop_4), mean(prop_5)))
}
}
n_sim <- 50
## We vary three factors, and for the simulation study, we
## cross-examine them through a nested for loop
## TUPLES
power_results <- data.frame(test_length = NA, sample_size = NA, LR2 = NA,
LR3 = NA, LR4 = NA, Chisq = NA, P_Chisq = NA)
for(a in levels(test_length)){
for(b in levels(sample_size)){
prop_1 <- rep(NA, n_sim)
prop_2 <- rep(NA, n_sim)
prop_3 <- rep(NA, n_sim)
prop_4 <- rep(NA, n_sim)
prop_5 <- rep(NA, n_sim)
n <- as.numeric(as.character(b))
k <- as.numeric(as.character(a))
for(i in 1:n_sim){
## Then, for every condition, generate data according to the
## current condition
temp_data <- data.gen(n = n,
k = k,
model = "3PL")
p_value_1 <- 1 - pchisq(q = -2 * LR.test(data = temp_data,
model = "2PL", g = 2),
df = k)
p_value_2 <- 1 - pchisq(q = -2 * LR.test(data = temp_data,
model = "2PL", g = 3),
df = 2 * k)
p_value_3 <- 1 - pchisq(q = -2 * LR.test(data = temp_data,
model = "2PL", g = 4),
df = 3 * k)
p_value_4 <- 1
p_value_5 <- 1
prop_1[i] <- ifelse(p_value_1 < .05, 1, 0)
prop_2[i] <- ifelse(p_value_2 < .05, 1, 0)
prop_3[i] <- ifelse(p_value_3 < .05, 1, 0)
prop_4[i] <- ifelse(p_value_4 < .05, 1, 0)
prop_5[i] <- ifelse(p_value_5 < .05, 1, 0)
}
power_results <- rbind(power_results, c(a, b, mean(prop_1), mean(prop_2),
mean(prop_3), mean(prop_4), mean(prop_5)))
}
}
View(power_results)
?subset
temp_data <- as.data.frame(temp_data)
temp_data$split <- sample(1:3, nrow(temp_data), replace = TRUE)
View(temp_data)
subset(temp_data, split == 1, select = -split)
