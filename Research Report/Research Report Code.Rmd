---
title: "Master Thesis Code"
author: "Nina van Gerwen (1860852)"
date: "2022-10-28"
output: html_document
---

## Functions for IRF calculations

These are necessary in data generation as we will vary the data generating model.

```{r IRF calculation functions}
one.pl <- function(theta, beta){
  prob <- exp(theta - beta) / (1 + exp(theta - beta))
  return(prob)
}
## Question Dave: is er een probleem met ene functie - beta en andere + beta

two.pl <- function(theta, alpha, beta){
  prob <- exp((alpha * theta) + beta) / (1 + exp((alpha * theta) + beta))
  return(prob)
}

three.pl <- function(theta, alpha, beta, gamma){
  prob <- gamma + (1 - gamma) * (exp((alpha * theta) + beta) / (1 + exp((alpha + theta) + beta)))
  return(prob)
}

```

## Function for data generation

Now we create the function for data generation, where the input is 
sample size, test length and the true model.

```{r Data generation functions}
data.gen <- function(n, k, model = "1PL"){
  theta <- matrix(data = rep(rnorm(n), k), ncol = k)
  
  beta <- matrix(data = rep(c(-2, -1, 0, 1, 2), k), nrow = n, ncol = k, byrow = TRUE)
  
  if(model == "1PL"){
    Z <- one.pl(theta = theta, beta = beta)
  
  }
  if(model == "2PL"){
      
    alpha <- matrix(data = rep(c(0.7, 0.85, 1, 1.15, 1.3), k), ncol = k,
                    nrow = n, byrow = TRUE)
  
    Z <- two.pl(theta = theta, alpha = alpha, beta = beta)
    
  }
  if(model == "3PL"){
    
    alpha <- matrix(data = rep(c(0.7, 0.85, 1, 1.15, 1.3), k), ncol = k,
                    nrow = n, byrow = TRUE)
  
    gamma <- 0.15 + rnorm(1, 0, 0.05)
  
    Z <- three.pl(theta = theta, alpha = alpha, beta = beta, gamma = gamma)
  }
  
data <- matrix(data = rbinom(n = n * k, size = 1, prob = Z), ncol = k, nrow = n)
  
return(data)

}
```

## Functions for model fit calculations

To fit the 1PL model, we can use the rasch() function.
To fit the 2PL model, we can use the ltm() function.
To fit the 3PL model, we can use the tpm() function.

```{r model fit calculation functions}

LR.test <- function(data, model = "1PL", g = 2){

  temp_data <- as.data.frame(data)
  temp_data$split <- sample(1:g, nrow(data), replace = TRUE)

  if(model == "1PL"){
    whole_log <- rasch(data = data)$log.Lik
  }
  if(model == "2PL"){
    whole_log <- ltm(data ~ z1, IRT.param = TRUE)$log.Lik
  }
  if(model == "3PL"){
    whole_log <- tpm(data)$log.Lik
  }
  
  split_LR_values <- rep(NA, g)
  for(j in 1:g) {
    if(model == "1PL"){
      
      
      split_LR_values[j] <- rasch(subset(temp_data, split == j, select = -split))$log.Lik
    }
    
    if(model == "2PL"){
      
      
      split_LR_values[j] <- ltm(subset(temp_data, split == j, select = -split) ~ z1, IRT.param = TRUE)$log.Lik
    }
    if(model == "3PL"){
      
      
      split_LR_values[j] <- tpm(subset(temp_data, split == j, select = -split))$log.Lik
    }
  }

  LR_value <- whole_log / prod(split_LR_values, na.rm = TRUE)
  return(LR_value)
}

```

## Functions for TFI/CLI calculatoins

```{r TLI/CLI functions}

```


## Testing the functions

```{r}

space <- list()

for(i in 1:100){
  temp_data <- data.gen(100, 5, "1PL")
  
  
}

library(ltm)
test_dat <- data.gen(100, 5, "1PL")
mml1 <- rasch(test_dat)
mml2 <- ltm(test_dat ~ z1, IRT.param = TRUE)
mml3 <- tpm(test_dat)

anova(mml1, mml2)
anova(mml2, mml3)
```

